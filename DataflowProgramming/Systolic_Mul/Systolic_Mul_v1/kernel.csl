// This program is the kernel pe
// for each kernel pe, it will:
// set beat to 1
// for beat < Cycle, do the following:

// first,  receive B from north, store B to local mem, send B to south
// second, receive A from west, fabin A to A_dsd, send A to east
// third, the arrival of A will trigger wtt block_matrix_multiply
// after completing block_matrix_multiply, receive B again

// when beat = Cycle, finish, and wait for memcpy_d2h come get the result

// Implementation
// B_color is blocked
// receive A. store in memdsd, unblock B_color
// wtt multiply(A_color) will start
    // fmacs(C_row_dsd, C_row_dsd, B_row_dsd, A_scalar)
// how do we repeat consuming fabindsd A and B multiply and add for exactly 'beat' times? 
const print = @import_module("<simprint>", .{ .enable = true });
const fabric = @import_module("<layout>");

param memcpy_params: comptime_struct;

// memcpy module provides infrastructure for copying data
// and launching functions from the host
const sys_mod = @import_module("<memcpy/memcpy>", memcpy_params);

//For future wse3 compatibility
const iq_A = @get_input_queue(3);

param Mt: i16;
param Kt: i16;
param Nt: i16;

param Pc:    i16;
param Cycle: i16;
param Pr:    i16;

param A_color:  color;
param B_color:  color;

const B_color_iq = @get_input_queue(2);

// task id
const B_transfer_task_id: local_task_id = @get_local_task_id(16);
const fmacs_task_id:       data_task_id = @get_data_task_id(A_color);
const terminate_task_id:  local_task_id = @get_local_task_id(17);

// Initialize
var B = @zeros([Kt*Nt]f32);
var C = @zeros([Mt*Nt]f32);
var C_ptr: [*]f32 = &C;

// B_dsd store B in row major
const B_input_dsd = @get_dsd(fabin_dsd, .{ .extent = Kt*Nt, .fabric_color = B_color, .input_queue = B_color_iq });
const B_mem1_dsd = @get_dsd(mem1d_dsd, .{ .extent = Kt*Nt, .base_address = &B });

// A_dsd store A in row major
// const A_dsd = @get_dsd(fabin_dsd, .{ .extent = Mt*Kt, .fabric_color = A_color });

var B_row_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{Kt} -> B[i] });
// var B_row_dsd = @get_dsd(mem1d_dsd, .{ .extent = Nt, .base_address = &B });

// C_dsd store partial result of C
var C_dsd  = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{Nt} -> C[i] });

fn init() void {
    const C_dsd_reset = @get_dsd(mem1d_dsd, .{ .extent = Mt*Nt, .base_address = &C });
    @fmovs(C_dsd_reset, 0.0);
    sys_mod.unblock_cmd_stream();
}

var A_row_counter: i16 = 0;
var A_col_counter: i16 = 0;
var beat: i16 = 0;
task fmacs (A_val: f32) void {
    print.fmt_no_nl("PE({d},{d}): ", .{ fabric.get_x_coord(), fabric.get_y_coord() });
    print.print_f32(A_val);
    print.print_string("\n");
    print.print_string("A values printed out\n");

    print.fmt_no_nl("PE({d},{d}): ", .{ fabric.get_x_coord(), fabric.get_y_coord() });
    print.print_string("B array is");
    for (@range(i16, @as(i16, Kt*Nt))) |i| {
        print.print_f32(B[i]);
        print.print_string(" ");
    }
    print.print_string("\n");

    @fmacs(C_dsd, C_dsd, B_row_dsd, A_val);
    
    var offset: i16 = Nt*(A_col_counter+1);
    A_col_counter += 1;
    B_row_dsd = @increment_dsd_offset(B_mem1_dsd, offset, f32);

    if (A_col_counter == Kt) {
        A_row_counter += 1;
        //Reset B_row_dsd
        B_row_dsd = @get_dsd(mem1d_dsd, .{ .extent = Nt, .base_address = &B });

        C_dsd = @increment_dsd_offset(C_dsd, Nt, f32);
        A_col_counter = 0;
        print.fmt_no_nl("PE({d},{d}): ", .{ fabric.get_x_coord(), fabric.get_y_coord() });
        print.print_string("Full row of A processed\n");
    }

    if (A_row_counter == Mt) {
        @block(fmacs_task_id);
        print.fmt_no_nl("PE({d},{d}): ", .{ fabric.get_x_coord(), fabric.get_y_coord() });
        print.print_string("Full block of A processed\n");
        beat += 1;
        if (beat == Cycle) {
            print.fmt_no_nl("PE({d},{d}): ", .{ fabric.get_x_coord(), fabric.get_y_coord() });
            print.print_string("Last block of A processed\n");
            @unblock(terminate_task_id);
        } else {
            print.fmt_no_nl("PE({d},{d}): ", .{ fabric.get_x_coord(), fabric.get_y_coord() });
            print.print_string("Preparing for next block of A/B\n");
            B_row_dsd = @get_dsd(mem1d_dsd, .{ .extent = Nt, .base_address = &B });
            C_dsd = @get_dsd(mem1d_dsd, .{ .extent = Nt, .base_address = &C });
            A_row_counter = 0;
            @activate(B_transfer_task_id);
        }
    }
}

task B_transfer() void {
    @mov32(B_mem1_dsd, B_input_dsd, . { .async = true, .unblock = fmacs_task_id });
}

fn rpc_sync() void {
    print.fmt_no_nl("PE({d},{d}): ", .{ fabric.get_x_coord(), fabric.get_y_coord() });
    print.print_string("rpc_sync started\n");
    @activate(terminate_task_id);
}

task terminate() void {
    @block(terminate_task_id);
    print.fmt_no_nl("PE({d},{d}): ", .{ fabric.get_x_coord(), fabric.get_y_coord() });
    print.print_string("Unblocking command stream\n");
    sys_mod.unblock_cmd_stream();
}

comptime {
    @bind_local_task(B_transfer, B_transfer_task_id);
    @bind_data_task(fmacs, fmacs_task_id);
    @bind_local_task(terminate, terminate_task_id);

    @activate(B_transfer_task_id);
    @block(terminate_task_id);
    @block(fmacs_task_id);
    
    @export_symbol(C_ptr, "C");
    @export_symbol(rpc_sync);
    @export_symbol(init);

    if (@is_arch("wse3")){
        // WTT must bind to an input queue
        @initialize_queue(resources.iq_A, .{.color = A_color} );
    }
}